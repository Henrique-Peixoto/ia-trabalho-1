import math
import random
from typing import Tuple

from othello.gamestate import GameState
from othello.board import Board

# import othello

# Voce pode criar funcoes auxiliares neste arquivo
# e tambem modulos auxiliares neste pacote.
#
# Nao esqueca de renomear 'your_agent' com o nome
# do seu agente.

our_player = 'B'

class Node:
    def __init__(self, state, wins, plays, available_moves, father_node, generated_by, sons):
        self.state = state
        self.wins = wins
        self.plays = plays
        self.available_moves = available_moves
        self.father_node = father_node
        self.generated_by = generated_by
        self.sons = sons

    def __repr__(self):
        return 'Wins: ' + str(self.wins) + '\n' \
               'Plays: ' + str(self.plays) + '\n' \
               'Available moves: ' + str(self.available_moves) + '\n' \
               'Father node: ' + str(self.father_node) + '\n' \
               'Generated by: ' + str(self.generated_by) + '\n' \
               'Player: ' + str(self.state.player) + '\n' \
               'Board: \n' + str(self.state.board)


def make_move(state: GameState) -> Tuple[int, int]:
    """
    Returns an Othello move
    :param state: state to make the move
    :return: (int, int) tuple with x, y coordinates of the move (remember: 0 is the first row/column)
    """
    # o codigo abaixo apenas retorna um movimento aleatorio valido para
    # a primeira jogada com as pretas.
    # Remova-o e coloque a sua implementacao da poda alpha-beta

    root_node = Node(state, 0, 0, state.legal_moves(), None, None, [])
    print(root_node)
    select_node(root_node)

    # Testando jogadas
    # print(state.get_board())
    # print(state.player)
    # print(state.legal_moves())
    # next_state = state.next_state((2, 3))
    # print(next_state.get_board())
    # print(next_state.player)
    # print(next_state.legal_moves())
    # next_state = next_state.next_state((4, 2))
    # print(next_state.board)
    # print(next_state.player)
    # print(next_state.legal_moves())
    # next_state = next_state.next_state((5, 5))
    # print(next_state.board)
    # print(next_state.player)
    # print(next_state.legal_moves())

    # return random.choice([(2, 3), (4, 5), (5, 4), (3, 2)])


def calculate_ucb(node, father_node) -> float:
    son_wins = node.wins
    son_plays = node.plays
    father_plays = father_node.plays

    if son_plays == 0:
        return float('inf')

    exploitation = son_wins/son_plays
    exploration = 2*math.sqrt(2)*math.sqrt(2*math.log(father_plays, math.e)/son_plays)

    ucb = exploitation + exploration

    return ucb


def select_node(root: Node) -> Node:
    # Especialmente útil para a raiz, mas sem utilidade para os outros nodos
    # if len(root.available_moves) > 0:
    #     expand_node(root)

    biggest_ucb = -1
    selected_node = root
    father_node = root
    sons = father_node.sons

    while True:
        # Para cada nível da árvore, escolhemos o filho com maior UCB
        for node in sons:
            current_ucb = calculate_ucb(node, father_node)

            if current_ucb > biggest_ucb:
                biggest_ucb = current_ucb
                selected_node = node

        # Se o filho for uma folha, então o expandimos
        if len(selected_node.available_moves) > 0:
            break

        sons = selected_node.sons
        father_node = selected_node

    node = expand_node(selected_node)
    return root


def expand_node(node: Node) -> Node:
    # TODO: quando receber um nodo que é um estado terminal, não terá movimentos disponíveis
    # então algo precisa ser feito, talvez encerrar o algoritmo e retornar uma resposta
    # ou continuar procurando por outros caminhos enquanto houver tempo
    new_move = node.available_moves.pop()
    new_state = node.state.next_state(new_move)
    # TODO: é realmente necessário manter o new_state.legal_moves() ou poderia usar isso
    # no atributo new_state
    new_node = Node(new_state, 0, 0, new_state.legal_moves(), node, new_move, [])
    node.sons.append(new_node)
    simulate_game(new_state, new_node)

    return node


def simulate_game(state: GameState, node: Node) -> GameState:
    moves = state.legal_moves()
    new_move = moves.pop()
    new_state = state.next_state(new_move)

    while new_state.player is not None:
        moves = new_state.legal_moves()
        # TODO: esse pop() parece determinístico, sempre retorna o mesmo par!
        new_move = moves.pop()
        new_state = new_state.next_state(new_move)

    print(new_state.board)

    backpropagate(new_state, node)

    return state


def backpropagate(state: GameState, node: Node) -> Node:
    plays_increment = 1
    wins_increment = 0
    winner = state.winner()

    if winner == our_player:
        wins_increment = 1

    current_node = node
    last_visited_node = node
    while current_node is not None:
        current_node.plays += plays_increment
        current_node.wins += wins_increment
        # Usado só para ver o estado final da raiz, pode ser retirado depois
        last_visited_node = current_node
        current_node = current_node.father_node

    print(last_visited_node)

    return node


tabuleiro = Board()
gameState = GameState(tabuleiro, 'B')
make_move(gameState)

# TODO: filho do um nodo devem ser colocados num array
# TODO: moves_made deveria receber o conjunto retornado por legal_moves e ir retirando movimentos
# a medida que são usados
# TODO: pesquisar alternativas mais listas, alguma estrutura mais eficiente
# TODO: verificar se gera melhor desempenho guardar o valor UCB na classe Node
